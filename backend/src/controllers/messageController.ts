import { Request, Response } from 'express';
import { generateReplySuggestions, getFallbackSuggestions } from '../services/llmService.js';
import { saveMessage, getUserMessages, deleteMessage, logUsage } from '../services/firebaseService.js';
import { cacheService } from '../services/cacheService.js';
import { AppError, GenerateReplyRequest, GenerateReplyResponse, Message } from '../types/index.js';
import { asyncHandler } from '../middleware/errorHandler.js';

/**
 * Generate reply suggestions
 */
export const generateReply = asyncHandler(async (req: Request, res: Response) => {
  if (!req.user?.uid) {
    throw new AppError(401, 'Unauthorized', 'NO_USER');
  }

  const { message, tone, recentMessages } = req.body as GenerateReplyRequest;

  // Validate input
  if (!message || !tone) {
    throw new AppError(400, 'Message and tone are required', 'MISSING_FIELDS');
  }

  const validTones = ['friendly', 'professional', 'assertive', 'apologetic', 'casual'];
  if (!validTones.includes(tone)) {
    throw new AppError(400, `Invalid tone. Must be one of: ${validTones.join(', ')}`, 'INVALID_TONE');
  }

  const startTime = Date.now();

  try {
    // Check cache first
    const cached = cacheService.get(message, tone);
    if (cached) {
      const responseTime = Date.now() - startTime;
      
      // Log usage in background
      logUsage(req.user.uid, tone, 0, responseTime).catch(console.error);

      const response: GenerateReplyResponse = {
        suggestions: cached,
        cached: true,
        tokensUsed: 0,
      };
      res.json({ success: true, data: response });
      return;
    }

    // Generate suggestions using LLM
    const result = await generateReplySuggestions(message, tone, recentMessages || []);
    const responseTime = Date.now() - startTime;

    // Cache result
    cacheService.set(message, tone, result.suggestions);

    // Log usage in background
    logUsage(req.user.uid, tone, result.tokensUsed, responseTime).catch(console.error);

    const response: GenerateReplyResponse = {
      suggestions: result.suggestions,
      cached: false,
      tokensUsed: result.tokensUsed,
    };

    res.json({ success: true, data: response });
  } catch (error) {
    console.error('Error generating reply:', error);

    // Fallback to pre-generated suggestions
    const fallbackSuggestions = getFallbackSuggestions(tone);
    const response: GenerateReplyResponse = {
      suggestions: fallbackSuggestions,
      cached: false,
      tokensUsed: 0,
    };

    res.json({ success: true, data: response });
  }
});

/**
 * Save a message
 */
export const saveMessageHandler = asyncHandler(async (req: Request, res: Response) => {
  if (!req.user?.uid) {
    throw new AppError(401, 'Unauthorized', 'NO_USER');
  }

  const { originalMessage, tone, suggestions, selectedSuggestion, tokensUsed } = req.body;

  // Validate input
  if (!originalMessage || !tone || !suggestions) {
    throw new AppError(400, 'Missing required fields', 'MISSING_FIELDS');
  }

  const message: Message = {
    id: '', // Will be generated by Firebase
    userId: req.user.uid,
    originalMessage,
    tone,
    suggestions,
    selectedSuggestion,
    createdAt: new Date().toISOString(),
    tokensUsed: tokensUsed || 0,
    cached: false,
  };

  const messageId = await saveMessage(req.user.uid, message);

  res.status(201).json({
    success: true,
    data: { id: messageId, ...message },
  });
});

/**
 * Get user messages
 */
export const getMessages = asyncHandler(async (req: Request, res: Response) => {
  if (!req.user?.uid) {
    throw new AppError(401, 'Unauthorized', 'NO_USER');
  }

  const limit = Math.min(parseInt(req.query.limit as string) || 50, 100);
  const offset = parseInt(req.query.offset as string) || 0;

  const messages = await getUserMessages(req.user.uid, limit, offset);

  res.json({
    success: true,
    data: {
      messages,
      limit,
      offset,
      total: messages.length,
    },
  });
});

/**
 * Delete a message
 */
export const deleteMessageHandler = asyncHandler(async (req: Request, res: Response) => {
  if (!req.user?.uid) {
    throw new AppError(401, 'Unauthorized', 'NO_USER');
  }

  const { messageId } = req.params;

  if (!messageId) {
    throw new AppError(400, 'Message ID is required', 'MISSING_MESSAGE_ID');
  }

  await deleteMessage(req.user.uid, messageId);

  res.json({ success: true, data: { message: 'Message deleted successfully' } });
});

/**
 * Search messages
 */
export const searchMessages = asyncHandler(async (req: Request, res: Response) => {
  if (!req.user?.uid) {
    throw new AppError(401, 'Unauthorized', 'NO_USER');
  }

  const { query, tone } = req.query as { query?: string; tone?: string };

  if (!query) {
    throw new AppError(400, 'Search query is required', 'MISSING_QUERY');
  }

  const messages = await getUserMessages(req.user.uid, 100);

  const filtered = messages.filter(msg => {
    const matchesQuery = msg.originalMessage.toLowerCase().includes(query.toLowerCase());
    const matchesTone = !tone || msg.tone === tone;
    return matchesQuery && matchesTone;
  });

  res.json({
    success: true,
    data: {
      messages: filtered,
      total: filtered.length,
    },
  });
});
